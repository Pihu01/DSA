`defaultdict` is a subclass of Python's regular dictionary that automatically creates missing values when you try to access a key that doesn't exist.

## Regular dict vs defaultdict:

**Regular dictionary:**
```python
regular_dict = {}
regular_dict['key1'].append('value')  # ❌ KeyError! 'key1' doesn't exist
```

**defaultdict:**
```python
from collections import defaultdict

dd = defaultdict(list)  # Automatically creates empty list for missing keys
dd['key1'].append('value')  # ✅ Works! Creates empty list first, then appends
```

## How defaultdict works:## Key benefits of defaultdict:

1. **Eliminates KeyError**: No need to check if key exists
2. **Cleaner code**: Less `if key in dict` checks
3. **Automatic initialization**: Creates appropriate empty container
4. **Performance**: Slightly faster than manual key checking

## Common default factories:

- `defaultdict(list)` → Creates empty `[]` for new keys
- `defaultdict(int)` → Creates `0` for new keys  
- `defaultdict(set)` → Creates empty `set()` for new keys
- `defaultdict(str)` → Creates empty `""` for new keys
- `defaultdict(dict)` → Creates empty `{}` for new keys

## In the buddy strings problem:

Instead of writing:
```python
if key not in groups:
    groups[key] = []
groups[key].append(string)
```

You can simply write:
```python
groups = defaultdict(list)
groups[key].append(string)  # Automatically creates [] if key is new
```

This makes the code more readable and less error-prone, especially when you're grouping items by some pattern or key!


from collections import defaultdict

# EXAMPLE 1: Basic usage with different default factories
print("=== Basic defaultdict usage ===")

# With list as default factory
dd_list = defaultdict(list)
dd_list['fruits'].append('apple')
dd_list['fruits'].append('banana')
dd_list['vegetables'].append('carrot')
print("defaultdict(list):", dict(dd_list))
# Output: {'fruits': ['apple', 'banana'], 'vegetables': ['carrot']}

# With int as default factory (useful for counting)
dd_int = defaultdict(int)
dd_int['apples'] += 1
dd_int['apples'] += 1
dd_int['oranges'] += 1
print("defaultdict(int):", dict(dd_int))
# Output: {'apples': 2, 'oranges': 1}

# With set as default factory
dd_set = defaultdict(set)
dd_set['group1'].add('Alice')
dd_set['group1'].add('Bob')
dd_set['group2'].add('Charlie')
print("defaultdict(set):", dict(dd_set))
# Output: {'group1': {'Alice', 'Bob'}, 'group2': {'Charlie'}}

print("\n=== Comparison: Regular dict vs defaultdict ===")

# Regular dictionary approach (more verbose)
def group_by_length_regular(words):
    result = {}
    for word in words:
        length = len(word)
        if length not in result:
            result[length] = []  # Manual initialization
        result[length].append(word)
    return result

# defaultdict approach (cleaner)
def group_by_length_defaultdict(words):
    result = defaultdict(list)
    for word in words:
        length = len(word)
        result[length].append(word)  # No need to check if key exists
    return result

words = ['cat', 'dog', 'elephant', 'bee', 'tiger']
print("Regular dict result:", group_by_length_regular(words))
print("defaultdict result:", dict(group_by_length_defaultdict(words)))

print("\n=== Why defaultdict is useful in buddy strings problem ===")

# In our buddy strings problem:
def demonstrate_buddy_grouping():
    strings = ["abc", "def", "xyz", "ace"]
    
    # Without defaultdict (more code)
    groups_regular = {}
    for s in strings:
        length = len(s)
        # Calculate distances manually for demo
        distances = []
        for i in range(len(s) - 1):
            distances.append(ord(s[i+1]) - ord(s[i]))
        
        key = (length, tuple(distances))
        
        if key not in groups_regular:
            groups_regular[key] = []  # Manual initialization
        groups_regular[key].append(s)
    
    # With defaultdict (cleaner)
    groups_defaultdict = defaultdict(list)
    for s in strings:
        length = len(s)
        distances = []
        for i in range(len(s) - 1):
            distances.append(ord(s[i+1]) - ord(s[i]))
        
        key = (length, tuple(distances))
        groups_defaultdict[key].append(s)  # No manual check needed
    
    print("Regular dict approach:")
    for key, group in groups_regular.items():
        print(f"  {key}: {group}")
    
    print("defaultdict approach:")
    for key, group in groups_defaultdict.items():
        print(f"  {key}: {group}")

demonstrate_buddy_grouping()

print("\n=== Different default factories ===")

# Custom default factory
def default_factory():
    return "Not found"

dd_custom = defaultdict(default_factory)
dd_custom['existing'] = "I exist"
print("Custom factory:")
print(f"  Existing key: {dd_custom['existing']}")
print(f"  Missing key: {dd_custom['missing']}")

# Lambda as default factory
dd_lambda = defaultdict(lambda: [0, 0])
dd_lambda['player1'][0] = 10  # score
dd_lambda['player1'][1] = 5   # lives
print("Lambda factory:", dict(dd_lambda))

print("\n=== Common use cases ===")

# 1. Grouping items
def group_students_by_grade():
    students = [('Alice', 'A'), ('Bob', 'B'), ('Charlie', 'A'), ('David', 'B')]
    
    grades = defaultdict(list)
    for name, grade in students:
        grades[grade].append(name)
    
    return dict(grades)

print("Students by grade:", group_students_by_grade())

# 2. Counting occurrences
def count_characters(text):
    counter = defaultdict(int)
    for char in text:
        counter[char] += 1
    return dict(counter)

print("Character count:", count_characters("hello world"))

# 3. Nested grouping
def nested_grouping():
    # Group by first letter, then by length
    words = ['apple', 'ant', 'banana', 'bee', 'cat', 'car']
    
    nested = defaultdict(lambda: defaultdict(list))
    for word in words:
        first_letter = word[0]
        length = len(word)
        nested[first_letter][length].append(word)
    
    return {k: dict(v) for k, v in nested.items()}

print("Nested grouping:", nested_grouping())
